#!/usr/bin/env python3
"""
Generates random DIMACS CNF files for SAT testing.
Creates formulas and stores them in the tests/cnf/ folder.
"""

import argparse
import random
from pathlib import Path


def generate_sat_formula(num_vars, num_clauses, min_clause_length=2, max_clause_length=4, seed=None):
    """Generate a random SAT formula (not guaranteed to be satisfiable, but typically is)."""
    if seed is not None:
        random.seed(seed)

    formula = []
    for _ in range(num_clauses):
        clause_length = random.randint(min_clause_length, max_clause_length)
        variables = random.sample(range(1, num_vars + 1), min(clause_length, num_vars))
        clause = [v if random.random() > 0.5 else -v for v in variables]
        formula.append(clause)

    return formula


def generate_unsat_pigeonhole(num_pigeons=None, num_holes=None):
    """
    Generate an unsatisfiable pigeonhole formula.
    Tries to put (num_holes + 1) pigeons into num_holes holes.
    """
    if num_holes is None:
        num_holes = random.randint(3, 10)
    if num_pigeons is None:
        num_pigeons = num_holes + 1

    # Variable x_ij means pigeon i is in hole j
    # Variable numbering: pigeon i (1..num_pigeons), hole j (1..num_holes) -> var = (i-1)*num_holes + j
    def var(pigeon, hole):
        return (pigeon - 1) * num_holes + hole

    num_vars = num_pigeons * num_holes
    formula = []

    # Each pigeon must be in at least one hole
    for i in range(1, num_pigeons + 1):
        clause = [var(i, j) for j in range(1, num_holes + 1)]
        formula.append(clause)

    # No two pigeons in the same hole
    for j in range(1, num_holes + 1):
        for i1 in range(1, num_pigeons + 1):
            for i2 in range(i1 + 1, num_pigeons + 1):
                formula.append([-var(i1, j), -var(i2, j)])

    return formula, num_vars


def generate_unsat_contradiction(num_vars, seed=None):
    """
    Generate an unsatisfiable formula using direct contradictions.
    Forces a variable to be both true and false.
    """
    if seed is not None:
        random.seed(seed)

    formula = []

    # Pick a variable and force it to be both true and false
    conflict_var = random.randint(1, num_vars)

    # Add clauses that force conflict_var to be true
    formula.append([conflict_var])

    # Add clauses that force conflict_var to be false
    formula.append([-conflict_var])

    for _ in range(random.randint(5, 15)):
        clause_length = random.randint(2, 4)
        variables = random.sample(range(1, num_vars + 1), min(clause_length, num_vars))
        clause = [v if random.random() > 0.5 else -v for v in variables]
        formula.append(clause)

    return formula


def get_unique_filename(base_dir, base_name):
    """
    Generate a unique filename. If the file exists, append (counter) to the name.
    """
    filepath = Path(base_dir) / f"{base_name}.cnf"

    if not filepath.exists():
        return filepath

    counter = 1
    while True:
        new_name = f"{base_name} ({counter})"
        filepath = Path(base_dir) / f"{new_name}.cnf"
        if not filepath.exists():
            return filepath
        counter += 1


def write_dimacs(formula, num_vars, filepath, is_sat=True):
    """Write a formula in DIMACS CNF format."""
    num_clauses = len(formula)

    with open(filepath, 'w') as f:
        f.write(f"c Expected: {'SAT' if is_sat else 'UNSAT'}\n")
        f.write(f"c Generated by generate.py\n")
        f.write(f"p cnf {num_vars} {num_clauses}\n")

        for clause in formula:
            f.write(" ".join(map(str, clause)) + " 0\n")


def main():
    parser = argparse.ArgumentParser(description='Generate random DIMACS CNF files')
    parser.add_argument('--vars', type=int, default=50, help='Number of variables (default: 50)')
    parser.add_argument('--clauses', type=int, default=200, help='Number of clauses (default: 200)')
    parser.add_argument('--min-clause-length', type=int, default=2, help='Minimum clause length (default: 2)')
    parser.add_argument('--max-clause-length', type=int, default=4, help='Maximum clause length (default: 4)')
    parser.add_argument('--seed', type=int, default=None, help='Random seed for reproducibility')
    parser.add_argument('-o', '--output', type=str, default=None, help='Output file path (overrides default naming)')
    parser.add_argument('--type', choices=['sat', 'unsat-pigeonhole', 'unsat-contradiction', 'both'],
                        default='both', help='Type of formula to generate (default: both)')
    parser.add_argument('--output-dir', type=str, default='tests/cnf', help='Output directory (default: tests/cnf)')

    args = parser.parse_args()

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    types_to_generate = []
    if args.type == 'both':
        types_to_generate = ['sat', 'unsat']
    elif args.type.startswith('unsat'):
        types_to_generate = ['unsat']
    else:
        types_to_generate = ['sat']

    for formula_type in types_to_generate:
        if args.output and len(types_to_generate) == 1:
            filepath = Path(args.output)
        else:
            if formula_type == 'sat':
                base_name = f"random_sat_{args.vars}_{args.clauses}"
            else:
                base_name = f"random_unsat_{args.vars}_{args.clauses}"

            filepath = get_unique_filename(output_dir, base_name)

        if formula_type == 'sat':
            formula = generate_sat_formula(
                args.vars,
                args.clauses,
                args.min_clause_length,
                args.max_clause_length,
                args.seed
            )
            num_vars = args.vars
            is_sat = True
        else:
            if args.type == 'unsat-pigeonhole':
                num_holes = max(3, args.vars // 4)
                formula, num_vars = generate_unsat_pigeonhole(num_holes=num_holes)
            else:
                formula = generate_unsat_contradiction(args.vars, args.seed)
                num_vars = args.vars

            is_sat = False

        write_dimacs(formula, num_vars, filepath, is_sat)

        status = "SAT" if is_sat else "UNSAT"
        print(f"Generated {status} formula: {filepath}")
        print(f"  Variables: {num_vars}, Clauses: {len(formula)}")


if __name__ == '__main__':
    main()

